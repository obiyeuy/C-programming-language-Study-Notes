//  v = (-1)^s*M*2^E

// s 是符号位的数字，如果 s 为0则浮点数V是正数，如果 s 为 1，则浮点数 V 为负数。
// M 表示有效数字[1,2),而 E 是阶数位，float的E是8位，而double的E是11位
// 单精度存储模型：s占一个bit，阶码占8bit，M中的小数点后数字占23bit（共4字节）
// 双精度存储模型：s占1bit，E占11bit，M占52bit（共8字节） 注：与32位或64位系统无关

// 阶码 : 阶码需要作移码运算，阶码的计算公式是：阶数 + 偏移量。在转换出来的二进制数里，阶数是111(十进制为7)，对于单精度的浮点数，偏移值为01111111(127)
// 阶码不包括全零和全一的情况（阶数为0，代表(-1)^s*M*2^(-127),趋近于数字0; 阶数为全1，代表(-1)^s*M*2^128,趋近于无穷大）
// [注：偏移量的计算方法是：2^(e-1)-1 ，其中e为阶码的位数，单精度浮点数阶码位数为8，因此偏移值是127]

// 如5.5 二进制表示为101.1
//  即s=0  ,M=1.011  ,E=2
//  0100 0000 1011 0000 0000 0000 0000 0000z 则0为符号位;2二进制为01，再加偏移量01111111，则为10000001;尾数为01100000000000000000000  注：阶码与尾数间隐含小数点
//  0x40b00000



#include<stdio.h>

// int main(){
//     float a = 5.5;  // 看内存 为00 00 b0 40（小端存储）
//     float* p = &a;  // 注：vscode看内存只能用指针

//     return 0;
// }



int main(){
    int n = 9;
    // 0 00000000 00000000000000000001001  补码

    float* p = (float*)&n;
    printf("n的值为: %d\n", n);
    printf("p的值为:%f\n", *p);
    // (-1)^0*0.00000000000000000001001*2^(-126)  则为0.00000

    *p = 9.0;
    // 0 10000010 00100000000000000000000
    printf("n的值为: %d\n", n);   // 即n补码为0100 0001 0001 0000 0000 0000 0000 0000 
                                 // 则n为1,091,567,616
    printf("p的值为:%f\n", *p);   

    return 0;

}